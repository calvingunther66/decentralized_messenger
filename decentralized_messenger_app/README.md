# Decentralized Messenger Application

This project outlines the architecture and provides foundational code for a cross-platform decentralized messaging application. The core idea is to enable direct device-to-device communication using various local networking technologies (Bluetooth, Wi-Fi Direct, UWB, NFC) without relying on central servers.

**Important Disclaimer:**
Implementing real, cross-platform peer-to-peer communication over low-level technologies like Bluetooth, Wi-Fi Direct, NFC, and UWB is **extremely complex** and requires deep knowledge of each operating system's native APIs. This project provides a conceptual framework and foundational code, but the full implementation of the native P2P communication layer will be a significant undertaking. For demonstration purposes, the Android native module includes a *simulated* P2P layer using local file storage.

## Architecture Overview

The application is structured into three main layers:

1.  **Core Logic (Rust Library):**
    *   **Purpose:** Handles all critical, platform-independent logic, including cryptographic operations (RSA, AES), user identity management, and message protocol serialization/deserialization.
    *   **Technology:** Rust. Rust is chosen for its performance, memory safety, and excellent Foreign Function Interface (FFI) capabilities, allowing a single codebase to be compiled into native libraries for all target platforms.
    *   **Output:** Native static/dynamic libraries (`.a`, `.so`, `.dylib`, `.dll`) for each target OS.

2.  **P2P Communication Layer (Native Code):**
    *   **Purpose:** Manages device discovery, connection establishment, and raw data transfer over specific local networking technologies. This layer is inherently platform-dependent due to OS restrictions and hardware-specific APIs.
    *   **Technology:**
        *   **iOS:** Swift/Objective-C (using `CoreBluetooth`, `MultipeerConnectivity`, `NearbyInteraction` for UWB).
        *   **Android:** Kotlin/Java (using `BluetoothManager`, `WifiP2pManager`, `UwbManager`, and potentially `Nearby Connections API`).
        *   **Windows:** C#/C++ (using `Windows.Devices.Bluetooth`, `Windows.Networking.Proximity`, Wi-Fi Direct APIs).
        *   **macOS:** Swift/Objective-C (using `CoreBluetooth`, `MultipeerConnectivity`).
        *   **Linux:** C/C++ (using `BlueZ` for Bluetooth, and potentially `libiw` or direct socket programming for Wi-Fi P2P).
    *   **Integration:** These native modules call into the Rust core library for encryption/decryption and message formatting. They expose a consistent API to the Flutter UI layer.

3.  **User Interface (Flutter):**
    *   **Purpose:** Provides the cross-platform graphical user interface for the application.
    *   **Technology:** Flutter (Dart). This allows a single UI codebase to run on iOS, Android, Windows, macOS, and Linux.
    *   **Integration:** Flutter communicates with the native P2P communication modules using Platform Channels (`MethodChannel` for invoking native methods, `EventChannel` for receiving streams of data/events from native). For desktop platforms, Flutter's `dart:ffi` can directly interact with the Rust core library.

## Project Structure

```
decentralized_messenger_app/
├── decentralized_messenger_core/  # Rust core library
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
├── lib/                           # Flutter Dart code
│   ├── main.dart
│   └── ffi_bridge.dart            # Dart FFI bindings for desktop
├── android/                       # Android project (generated by Flutter)
│   └── app/
│       └── src/
│           └── main/
│               ├── kotlin/
│               │   └── com/example/decentralized_messenger_app/
│               │       └── MainActivity.kt
│               └── jniLibs/       # Place compiled Rust .so files here
│                   └── aarch64-v8a/
│                       └── libdecentralized_messenger_core.so
├── ios/                           # iOS project (generated by Flutter)
├── windows/                       # Windows desktop project (generated by Flutter)
├── macos/                         # macOS desktop project (generated by Flutter)
├── linux/                         # Linux desktop project (generated by Flutter)
└── pubspec.yaml                   # Flutter project dependencies
└── README.md                      # This file
```

## Setup and Building Instructions

### Step 1: Create the Flutter Project

First, you need to create the Flutter project. If you don't have Flutter installed, follow the official Flutter installation guide: [https://flutter.dev/docs/get-started/install](https://flutter.dev/docs/get-started/install)

```bash
flutter create decentralized_messenger_app
cd decentralized_messenger_app
```

### Step 2: Develop the Rust Core Library

The Rust core library contains the cryptographic and core logic.

1.  **Navigate to the Rust project directory:**
    ```bash
    cd decentralized_messenger_app/decentralized_messenger_core
    ```

2.  **Create `Cargo.toml`:**
    Create a file named `Cargo.toml` in this directory with the following content:
    ```toml
    # decentralized_messenger_app/decentralized_messenger_core/Cargo.toml
    [package]
    name = "decentralized_messenger_core"
    version = "0.1.0"
    edition = "2021"

    [lib]
    crate-type = ["cdylib", "staticlib"] # For dynamic and static linking

    [dependencies]
    rand = "0.8" # For random ID generation
    hex = "0.4" # For hex encoding/decoding IDs
    serde = { version = "1.0", features = ["derive"] } # For serialization/deserialization
    serde_json = "1.0"
    rsa = { version = "0.9", features = ["serde"] } # For RSA encryption
    aes-gcm = "0.10" # For AES encryption
    base64 = "0.21" # For base64 encoding
    # For FFI (Foreign Function Interface)
    libc = "0.2"
    # For AES IV
    rand_core = { version = "0.6", features = ["std"] }
    # For AES key generation
    getrandom = "0.2"
    ```

3.  **Create `src/lib.rs`:**
    Create a file named `lib.rs` inside the `src` directory (`decentralized_messenger_app/decentralized_messenger_core/src/lib.rs`) with the following content:
    ```rust
    // decentralized_messenger_app/decentralized_messenger_core/src/lib.rs
    use rsa::{RsaPrivateKey, RsaPublicKey, pkcs1v15, traits::{PublicKeyParts, PrivateKeyParts}};
    use rand::rngs::OsRng;
    use serde::{Serialize, Deserialize};
    use std::ffi::{CStr, CString};
    use std::os::raw::c_char;
    use serde_json;
    use aes_gcm::{Aes256Gcm, Key, Nonce};
    use aes_gcm::aead::{Aead, NewAead};
    use base64::{engine::general_purpose, Engine as _};
    use rand_core::RngCore; // For generating random nonces

    // Structs for serialization/deserialization
    #[derive(Serialize, Deserialize, Debug)]
    pub struct RsaKeyPair {
        pub private_key_pem: String,
        pub public_key_pem: String,
    }

    #[derive(Serialize, Deserialize, Debug)]
    pub struct EncryptedMessage {
        pub iv: String,
        pub ciphertext: String,
    }

    // Helper to convert Rust String to C-compatible char pointer
    fn to_c_string(s: String) -> *mut c_char {
        CString::new(s).unwrap().into_raw()
    }

    // Helper to convert C-compatible char pointer to Rust String
    fn from_c_string(ptr: *const c_char) -> String {
        unsafe {
            CStr::from_ptr(ptr).to_string_lossy().into_owned()
        }
    }

    // --- RSA Key Pair Generation ---
    #[no_mangle]
    pub extern "C" fn generate_rsa_key_pair_ffi() -> *mut c_char {
        let mut rng = OsRng;
        let bits = 2048;
        let private_key = RsaPrivateKey::new(&mut rng, bits).expect("failed to generate a key");
        let public_key = RsaPublicKey::from(&private_key);

        let private_key_pem = private_key.to_pkcs1_pem(pkcs1v15::LineEnding::LF).unwrap();
        let public_key_pem = public_key.to_pkcs1_pem(pkcs1v15::LineEnding::LF).unwrap();

        let key_pair = RsaKeyPair {
            private_key_pem,
            public_key_pem,
        };

        let json_string = serde_json::to_string(&key_pair).unwrap();
        to_c_string(json_string)
    }

    // --- Encrypt AES Key with RSA Public Key ---
    #[no_mangle]
    pub extern "C" fn encrypt_aes_key_with_rsa_ffi(
        aes_key_base64_ptr: *const c_char,
        recipient_public_key_pem_ptr: *const c_char,
    ) -> *mut c_char {
        let aes_key_base64 = from_c_string(aes_key_base64_ptr);
        let recipient_public_key_pem = from_c_string(recipient_public_key_pem_ptr);

        let aes_key_bytes = general_purpose::STANDARD.decode(aes_key_base64).unwrap();
        let recipient_public_key = RsaPublicKey::from_pkcs1_pem(&recipient_public_key_pem).unwrap();

        let encrypted_aes_key = recipient_public_key.encrypt(
            &mut OsRng,
            pkcs1v15::Oaep::new::<sha2::Sha256, sha2::Sha256>(),
            &aes_key_bytes,
        ).unwrap();

        to_c_string(general_purpose::STANDARD.encode(encrypted_aes_key))
    }

    // --- Decrypt AES Key with RSA Private Key ---
    #[no_mangle]
    pub extern "C" fn decrypt_aes_key_with_rsa_ffi(
        encrypted_aes_key_base64_ptr: *const c_char,
        private_key_pem_ptr: *const c_char,
    ) -> *mut c_char {
        let encrypted_aes_key_base64 = from_c_string(encrypted_aes_key_base64_ptr);
        let private_key_pem = from_c_string(private_key_pem_ptr);

        let encrypted_aes_key_bytes = general_purpose::STANDARD.decode(encrypted_aes_key_base64).unwrap();
        let private_key = RsaPrivateKey::from_pkcs1_pem(&private_key_pem).unwrap();

        let decrypted_aes_key = private_key.decrypt(
            &mut OsRng,
            pkcs1v15::Oaep::new::<sha2::Sha256, sha2::Sha256>(),
            &encrypted_aes_key_bytes,
        ).unwrap();

        to_c_string(general_purpose::STANDARD.encode(decrypted_aes_key))
    }

    // --- Generate AES Key ---
    #[no_mangle]
    pub extern "C" fn generate_aes_key_ffi() -> *mut c_char {
        let key = Aes256Gcm::generate_key(&mut OsRng);
        to_c_string(general_purpose::STANDARD.encode(key))
    }

    // --- Encrypt Message with AES ---
    #[no_mangle]
    pub extern "C" fn encrypt_message_with_aes_ffi(
        message_ptr: *const c_char,
        aes_key_base64_ptr: *const c_char,
    ) -> *mut c_char {
        let message = from_c_string(message_ptr);
        let aes_key_base64 = from_c_string(aes_key_base64_ptr);

        let key_bytes = general_purpose::STANDARD.decode(aes_key_base64).unwrap();
        let key = Key::from_slice(&key_bytes);
        let cipher = Aes256Gcm::new(key);

        let mut nonce_bytes = [0u8; 12]; // GCM nonces are typically 96 bits (12 bytes)
        OsRng.fill_bytes(&mut nonce_bytes);
        let nonce = Nonce::from_slice(&nonce_bytes);

        let ciphertext = cipher.encrypt(nonce, message.as_bytes()).unwrap();

        let encrypted_msg = EncryptedMessage {
            iv: general_purpose::STANDARD.encode(nonce),
            ciphertext: general_purpose::STANDARD.encode(ciphertext),
        };

        to_c_string(serde_json::to_string(&encrypted_msg).unwrap())
    }

    // --- Decrypt Message with AES ---
    #[no_mangle]
    pub extern "C" fn decrypt_message_with_aes_ffi(
        iv_base64_ptr: *const c_char,
        ciphertext_base64_ptr: *const c_char,
        aes_key_base64_ptr: *const c_char,
    ) -> *mut c_char {
        let iv_base64 = from_c_string(iv_base64_ptr);
        let ciphertext_base64 = from_c_string(ciphertext_base64_ptr);
        let aes_key_base64 = from_c_string(aes_key_base64_ptr);

        let key_bytes = general_purpose::STANDARD.decode(aes_key_base64).unwrap();
        let key = Key::from_slice(&key_bytes);
        let cipher = Aes256Gcm::new(key);

        let nonce_bytes = general_purpose::STANDARD.decode(iv_base64).unwrap();
        let nonce = Nonce::from_slice(&nonce_bytes);

        let ciphertext_bytes = general_purpose::STANDARD.decode(ciphertext_base64).unwrap();

        let decrypted_bytes = cipher.decrypt(nonce, ciphertext_bytes.as_slice()).unwrap();

        to_c_string(String::from_utf8(decrypted_bytes).unwrap())
    }

    // --- Free C-strings allocated by Rust ---
    #[no_mangle]
    pub extern "C" fn free_cstring(s: *mut c_char) {
        unsafe {
            if s.is_null() { return; }
            let _ = CString::from_raw(s);
        }
    }
    ```

4.  **Build the Rust Library:**
    You need to have the Rust toolchain installed. Follow the instructions at [https://rustup.rs/](https://rustup.rs/).

    Navigate to the `decentralized_messenger_app/decentralized_messenger_core` directory in your terminal.

    *   **Add Target Platforms:**
        ```bash
        rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-androi d x86_64-linux-android # Android
        rustup target add aarch64-apple-ios armv7-apple-ios x86_64-apple-ios aarch64-apple-ios-sim # iOS
        rustup target add x86_64-pc-windows-msvc # Windows
        rustup target add x86_64-unknown-linux-gnu # Linux
        rustup target add x86_64-apple-darwin # macOS
        ```
    *   **Build Commands:**
        *   **For Android:** Use `cargo-ndk` for simplified cross-compilation.
            ```bash
            # Install cargo-ndk if you haven't already
            cargo install cargo-ndk
            # Build for common Android architectures
            cargo ndk build --target aarch64-linux-android --release
            cargo ndk build --target armv7-linux-androideabi --release
            cargo ndk build --target x86_64-linux-android --release
            ```
            The compiled `.so` files will be in `target/<android_target>/release/`.
        *   **For iOS:**
            ```bash
            cargo build --target aarch64-apple-ios --release
            cargo build --target x86_64-apple-ios-sim --release # For simulator
            ```
            The compiled `.a` (static library) files will be in `target/<ios_target>/release/`.
        *   **For Windows:**
            ```bash
            cargo build --target x86_64-pc-windows-msvc --release
            ```
            The compiled `.dll` and `.lib` files will be in `target/x86_64-pc-windows-msvc/release/`.
        *   **For macOS:**
            ```bash
            cargo build --target x86_64-apple-darwin --release
            ```
            The compiled `.dylib` and `.a` files will be in `target/x86_64-apple-darwin/release/`.
        *   **For Linux:**
            ```bash
            cargo build --target x86_64-unknown-linux-gnu --release
            ```
            The compiled `.so` file will be in `target/x86_64-unknown-linux-gnu/release/`.

### Step 3: Configure the Flutter Application

Navigate back to the root of your Flutter project: `cd ../` (from `decentralized_messenger_core`).

1.  **Update `pubspec.yaml`:**
    Open `decentralized_messenger_app/pubspec.yaml` and add the following dependencies:
    ```yaml
    # decentralized_messenger_app/pubspec.yaml
    name: decentralized_messenger_app
    description: A decentralized messaging application.
    publish_to: 'none' # Remove this line if you wish to publish to pub.dev

    version: 1.0.0+1

    environment:
      sdk: '>=3.0.0 <4.0.0'

    dependencies:
      flutter:
        sdk: flutter
      cupertino_icons: ^1.0.2
      # For direct FFI calls on desktop (optional, but good for Linux/Windows/macOS)
      ffi: ^2.1.0
      path_provider: ^2.1.1 # To get app-specific directories for data storage

    dev_dependencies:
      flutter_test:
        sdk: flutter
      flutter_lints: ^2.0.0

    flutter:
      uses-material-design: true
    ```

2.  **Create `lib/main.dart`:**
    Create a file named `main.dart` inside the `lib` directory (`decentralized_messenger_app/lib/main.dart`) with the following content:
    ```dart
    // decentralized_messenger_app/lib/main.dart
    import 'package:flutter/material.dart';
    import 'package:flutter/services.dart';
    import 'dart:convert'; // For JSON encoding/decoding

    // Define the MethodChannel for communication with native platform code
    const platformMethodChannel = MethodChannel('com.example.decentralized_messenger/p2p_methods');
    // Define the EventChannel for receiving streams of data from native platform code
    const platformEventChannel = EventChannel('com.example.decentralized_messenger/p2p_events');

    void main() {
      runApp(const MyApp());
    }

    class MyApp extends StatelessWidget {
      const MyApp({super.key});

      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          title: 'Decentralized Messenger',
          theme: ThemeData(
            primarySwatch: Colors.blue,
          ),
          home: const MessengerScreen(),
        );
      }
    }

    class MessengerScreen extends StatefulWidget {
      const MessengerScreen({super.key});

      @override
      State<MessengerScreen> createState() => _MessengerScreenState();
    }

    class _MessengerScreenState extends State<MessengerScreen> {
      final TextEditingController _recipientIdController = TextEditingController();
      final TextEditingController _messageController = TextEditingController();
      String _myPublicKey = 'Loading...';
      String _statusMessage = '';
      final List<String> _messages = [];

      @override
      void initState() {
        super.initState();
        _initMessenger();
        _listenForIncomingMessages();
      }

      Future<void> _initMessenger() async {
        try {
          // Call native method to initialize user or get existing ID/keys
          final String result = await platformMethodChannel.invokeMethod('initUser');
          final Map<String, dynamic> userData = jsonDecode(result);
          setState(() {
            _myPublicKey = userData['publicKey'] ?? 'Error getting public key';
            _statusMessage = 'Initialized with ID: ${userData['userId']}';
          });
        } on PlatformException catch (e) {
          setState(() {
            _statusMessage = "Failed to initialize: '${e.message}'.";
          });
        }
      }

      void _listenForIncomingMessages() {
        platformEventChannel.receiveBroadcastStream().listen((dynamic event) {
          setState(() {
            _messages.add('Received: $event');
          });
        }, onError: (dynamic error) {
          setState(() {
            _messages.add('Error receiving message: ${error.message}');
          });
        });
      }

      Future<void> _addContact() async {
        final String contactId = _recipientIdController.text;
        // In a real app, you'd get the contact's public key via some out-of-band method
        // For this prototype, we'll assume it's hardcoded or manually entered for testing.
        // For now, let's use a dummy public key or prompt the user.
        // This is where the initial key exchange would happen.
        // For simplicity, we'll just pass the contact ID for now, and assume the native side handles key exchange.
        try {
          final String result = await platformMethodChannel.invokeMethod('addContact', {
            'contactId': contactId,
            'contactPublicKey': 'DUMMY_PUBLIC_KEY_FOR_PROTOTYPE' // Replace with actual key input
          });
          setState(() {
            _statusMessage = result;
          });
        } on PlatformException catch (e) {
          setState(() {
            _statusMessage = "Failed to add contact: '${e.message}'.";
          });
        }
      }

      Future<void> _sendMessage() async {
        final String recipientId = _recipientIdController.text;
        final String messageContent = _messageController.text;

        if (recipientId.isEmpty || messageContent.isEmpty) {
          setState(() {
            _statusMessage = 'Recipient ID and message cannot be empty.';
          });
          return;
        }

        try {
          final String result = await platformMethodChannel.invokeMethod('sendMessage', {
            'recipientId': recipientId,
            'messageContent': messageContent,
          });
          setState(() {
            _statusMessage = result;
            _messages.add('Sent to $recipientId: $messageContent');
            _messageController.clear();
          });
        } on PlatformException catch (e) {
          setState(() {
            _statusMessage = "Failed to send message: '${e.message}'.";
          });
        }
      }

      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(
            title: const Text('Decentralized Messenger'),
          ),
          body: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('My Public Key: $_myPublicKey', style: const TextStyle(fontSize: 12)),
                const SizedBox(height: 8),
                Text('Status: $_statusMessage', style: const TextStyle(fontSize: 14, color: Colors.grey)),
                const SizedBox(height: 16),
                TextField(
                  controller: _recipientIdController,
                  decoration: const InputDecoration(
                    labelText: 'Recipient ID',
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: TextField(
                        controller: _messageController,
                        decoration: const InputDecoration(
                          labelText: 'Message',
                          border: OutlineInputBorder(),
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    ElevatedButton(
                      onPressed: _sendMessage,
                      child: const Text('Send'),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                ElevatedButton(
                  onPressed: _addContact,
                  child: const Text('Add Contact (Conceptual)'),
                ),
                const SizedBox(height: 16),
                const Text('Messages:', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                Expanded(
                  child: ListView.builder(
                    itemCount: _messages.length,
                    itemBuilder: (context, index) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 4.0),
                        child: Text(_messages[index]),
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
        );
      }
    }
    ```

3.  **Create `lib/ffi_bridge.dart` (for Desktop FFI):**
    Create a file named `ffi_bridge.dart` inside the `lib` directory (`decentralized_messenger_app/lib/ffi_bridge.dart`) with the following content:
    ```dart
    // decentralized_messenger_app/lib/ffi_bridge.dart
    import 'dart:ffi';
    import 'dart:io';
    import 'package:ffi/ffi.dart';
    import 'dart:convert';

    // Define the Rust library path based on the operating system
    final DynamicLibrary _rustLib = Platform.isWindows
        ? DynamicLibrary.open('decentralized_messenger_core.dll')
        : Platform.isMacOS
            ? DynamicLibrary.open('libdecentralized_messenger_core.dylib')
            : DynamicLibrary.open('libdecentralized_messenger_core.so');

    // Define the C function signatures
    typedef _GenerateRsaKeyPairC = Pointer<Utf8> Function();
    typedef _EncryptAesKeyWithRsaC = Pointer<Utf8> Function(Pointer<Utf8>, Pointer<Utf8>);
    typedef _DecryptAesKeyWithRsaC = Pointer<Utf8> Function(Pointer<Utf8>, Pointer<Utf8>);
    typedef _GenerateAesKeyC = Pointer<Utf8> Function();
    typedef _EncryptMessageWithAesC = Pointer<Utf8> Function(Pointer<Utf8>, Pointer<Utf8>);
    typedef _DecryptMessageWithAesC = Pointer<Utf8> Function(Pointer<Utf8>, Pointer<Utf8>, Pointer<Utf8>);
    typedef _FreeCStringC = Void Function(Pointer<Utf8>);

    // Define the Dart function types
    typedef _GenerateRsaKeyPairDart = Pointer<Utf8> Function();
    typedef _EncryptAesKeyWithRsaDart = Pointer<Utf8> Function(Pointer<Utf8>, Pointer<Utf8>);
    typedef _DecryptAesKeyWithRsaDart = Pointer<Utf8> Function(Pointer<Utf8>, Pointer<Utf8>);
    typedef _GenerateAesKeyDart = Pointer<Utf8> Function();
    typedef _EncryptMessageWithAesDart = Pointer<Utf8> Function(Pointer<Utf8>, Pointer<Utf8>);
    typedef _DecryptMessageWithAesDart = Pointer<Utf8> Function(Pointer<Utf8>, Pointer<Utf8>, Pointer<Utf8>);
    typedef _FreeCStringDart = void Function(Pointer<Utf8>);

    // Look up the functions in the shared library
    final _generateRsaKeyPair = _rustLib.lookupFunction<_GenerateRsaKeyPairC, _GenerateRsaKeyPairDart>('generate_rsa_key_pair_ffi');
    final _encryptAesKeyWithRsa = _rustLib.lookupFunction<_EncryptAesKeyWithRsaC, _EncryptAesKeyWithRsaDart>('encrypt_aes_key_with_rsa_ffi');
    final _decryptAesKeyWithRsa = _rustLib.lookupFunction<_DecryptAesKeyWithRsaC, _DecryptAesKeyWithRsaDart>('decrypt_aes_key_with_rsa_ffi');
    final _generateAesKey = _rustLib.lookupFunction<_GenerateAesKeyC, _GenerateAesKeyDart>('generate_aes_key_ffi');
    final _encryptMessageWithAes = _rustLib.lookupFunction<_EncryptMessageWithAesC, _EncryptMessageWithAesDart>('encrypt_message_with_aes_ffi');
    final _decryptMessageWithAes = _rustLib.lookupFunction<_DecryptMessageWithAesC, _DecryptMessageWithAesDart>('decrypt_message_with_aes_ffi');
    final _freeCString = _rustLib.lookupFunction<_FreeCStringC, _FreeCStringDart>('free_cstring');

    // Wrapper functions for easier Dart usage
    class RustCore {
      static Map<String, String> generateRsaKeyPair() {
        final ptr = _generateRsaKeyPair();
        final jsonString = ptr.toDartString();
        _freeCString(ptr); // Free the CString
        return Map<String, String>.from(jsonDecode(jsonString));
      }

      static String encryptAesKeyWithRsa(String aesKeyBase64, String recipientPublicKeyPem) {
        final ptr = _encryptAesKeyWithRsa(aesKeyBase64.toNativeUtf8(), recipientPublicKeyPem.toNativeUtf8());
        final result = ptr.toDartString();
        _freeCString(ptr);
        return result;
      }

      static String decryptAesKeyWithRsa(String encryptedAesKeyBase64, String privateKeyPem) {
        final ptr = _decryptAesKeyWithRsa(encryptedAesKeyBase64.toNativeUtf8(), privateKeyPem.toNativeUtf8());
        final result = ptr.toDartString();
        _freeCString(ptr);
        return result;
      }

      static String generateAesKey() {
        final ptr = _generateAesKey();
        final result = ptr.toDartString();
        _freeCString(ptr);
        return result;
      }

      static Map<String, String> encryptMessageWithAes(String message, String aesKeyBase64) {
        final ptr = _encryptMessageWithAes(message.toNativeUtf8(), aesKeyBase64.toNativeUtf8());
        final jsonString = ptr.toDartString();
        _freeCString(ptr);
        return Map<String, String>.from(jsonDecode(jsonString));
      }

      static String decryptMessageWithAes(String ivBase64, String ciphertextBase64, String aesKeyBase64) {
        final ptr = _decryptMessageWithAes(ivBase64.toNativeUtf8(), ciphertextBase64.toNativeUtf8(), aesKeyBase64.toNativeUtf8());
        final result = ptr.toDartString();
        _freeCString(ptr);
        return result;
      }
    }
    ```

### Step 4: Configure Android Native Module

This section describes how to set up the Android part of your Flutter app to interact with the Rust library and simulate P2P communication.

1.  **Place Rust Libraries:**
    After building the Rust library for Android (see Step 2.4), you need to copy the compiled `.so` files into the correct `jniLibs` directory within your Android project. For example, for the `aarch64-linux-android` target, you would copy `libdecentralized_messenger_core.so` to:
    ```
    decentralized_messenger_app/android/app/src/main/jniLibs/aarch64-v8a/
    ```
    You will need to manually create the `jniLibs` and architecture-specific subdirectories (e.g., `aarch64-v8a`, `armeabi-v7a`, `x86`, `x86_64`) and place the corresponding `.so` files there.

2.  **Modify `android/app/build.gradle`:**
    Open `decentralized_messenger_app/android/app/build.gradle` and ensure the `android` block includes `ndk` and `sourceSets` configurations to load the native libraries.

    ```gradle
    // decentralized_messenger_app/android/app/build.gradle
    // ... (existing content)

    android {
        // ... (existing content)

        defaultConfig {
            // ... (existing content)
            ndk {
                // Specify the ABIs you want to support and load native libraries for
                abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64'
            }
        }

        sourceSets {
            main {
                // Point to your jniLibs directory
                jniLibs.srcDirs = ['src/main/jniLibs']
            }
        }
    }

    // ... (existing content)
    ```

3.  **Create `MainActivity.kt`:**
    Create a file named `MainActivity.kt` inside the `decentralized_messenger_app/android/app/src/main/kotlin/com/example/decentralized_messenger_app/` directory with the following content:
    ```kotlin
    // decentralized_messenger_app/android/app/src/main/kotlin/com/example/decentralized_messenger_app/MainActivity.kt
    package com.example.decentralized_messenger_app

    import io.flutter.embedding.android.FlutterActivity
    import io.flutter.embedding.engine.FlutterEngine
    import io.flutter.plugin.common.MethodChannel
    import io.flutter.plugin.common.EventChannel
    import org.json.JSONObject
    import java.io.File
    import java.util.UUID
    import java.util.Base64 // For Base64 encoding/decoding
    import org.json.JSONArray // Explicitly import JSONArray

    class MainActivity: FlutterActivity() {
        private val METHOD_CHANNEL_NAME = "com.example.decentralized_messenger/p2p_methods"
        private val EVENT_CHANNEL_NAME = "com.example.decentralized_messenger/p2p_events"

        private lateinit var methodChannel: MethodChannel
        private lateinit var eventChannel: EventChannel
        private var eventSink: EventChannel.EventSink? = null

        // Load the Rust library
        companion object {
            init {
                System.loadLibrary("decentralized_messenger_core")
            }
        }

        // Declare native functions from Rust
        private external fun generate_rsa_key_pair_ffi(): String
        private external fun encrypt_aes_key_with_rsa_ffi(aesKeyBase64: String, recipientPublicKeyPem: String): String
        private external fun decrypt_aes_key_with_rsa_ffi(encryptedAesKeyBase64: String, privateKeyPem: String): String
        private external fun generate_aes_key_ffi(): String
        private external fun encrypt_message_with_aes_ffi(message: String, aesKeyBase64: String): String
        private external fun decrypt_message_with_aes_ffi(ivBase64: String, ciphertextBase64: String, aesKeyBase64: String): String
        // private external fun free_cstring(ptr: String) // Not needed if Rust returns managed strings or JSON

        // --- Simulated User Data and P2P Storage ---
        private var currentUserId: String? = null
        private var myPublicKey: String? = null
        private var myPrivateKey: String? = null
        private val contacts = mutableMapOf<String, ContactInfo>() // contactId -> ContactInfo

        data class ContactInfo(
            val publicKey: String,
            val conversationPrivateKey: String, // Our private key for this conversation
            val conversationPublicKey: String   // Our public key for this conversation
        )

        // Simulated storage for user data and inboxes
        private fun getUserDataFile(): File {
            return File(applicationContext.filesDir, "user_data.json")
        }

        private fun getInboxFile(userId: String): File {
            return File(applicationContext.filesDir, "inbox_${userId}.json")
        }

        private fun saveUserData() {
            val userData = JSONObject().apply {
                put("userId", currentUserId)
                put("publicKey", myPublicKey)
                put("privateKey", myPrivateKey)
                val contactsJson = JSONObject()
                contacts.forEach { (id, info) ->
                    contactsJson.put(id, JSONObject().apply {
                        put("publicKey", info.publicKey)
                        put("conversationPrivateKey", info.conversationPrivateKey)
                        put("conversationPublicKey", info.conversationPublicKey)
                    })
                }
                put("contacts", contactsJson)
            }
            getUserDataFile().writeText(userData.toString())
        }

        private fun loadUserData() {
            val file = getUserDataFile()
            if (file.exists()) {
                val json = file.readText()
                val userData = JSONObject(json)
                currentUserId = userData.optString("userId")
                myPublicKey = userData.optString("publicKey")
                myPrivateKey = userData.optString("privateKey")
                val contactsJson = userData.optJSONObject("contacts")
                contactsJson?.keys()?.forEach { key ->
                    val contactInfoJson = contactsJson.getJSONObject(key)
                    contacts[key] = ContactInfo(
                        contactInfoJson.getString("publicKey"),
                        contactInfoJson.getString("conversationPrivateKey"),
                        contactInfoJson.getString("conversationPublicKey")
                    )
                }
            }
        }

        // --- End Simulated User Data and P2P Storage ---


        override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
            super.configureFlutterEngine(flutterEngine)

            loadUserData() // Load user data on startup

            methodChannel = MethodChannel(flutterEngine.dartExecutor.binaryMessenger, METHOD_CHANNEL_NAME)
            methodChannel.setMethodCallHandler { call, result ->
                when (call.method) {
                    "initUser" -> {
                        if (currentUserId == null) {
                            // Create new user
                            val keyPairJson = generate_rsa_key_pair_ffi()
                            val keyPair = JSONObject(keyPairJson)
                            myPublicKey = keyPair.getString("public_key_pem")
                            myPrivateKey = keyPair.getString("private_key_pem")
                            currentUserId = UUID.randomUUID().toString().replace("-", "").substring(0, 100) // 100-char ID
                            saveUserData()
                        }
                        result.success(JSONObject().apply {
                            put("userId", currentUserId)
                            put("publicKey", myPublicKey)
                        }.toString())
                    }
                    "addContact" -> {
                        val contactId = call.argument<String>("contactId")
                        val contactPublicKey = call.argument<String>("contactPublicKey") // This would be exchanged in real P2P

                        if (contactId != null && contactPublicKey != null && !contacts.containsKey(contactId)) {
                            // Generate conversation-specific keys
                            val convKeyPairJson = generate_rsa_key_pair_ffi()
                            val convKeyPair = JSONObject(convKeyPairJson)
                            val convPrivateKey = convKeyPair.getString("private_key_pem")
                            val convPublicKey = convKeyPair.getString("public_key_pem")

                            contacts[contactId] = ContactInfo(contactPublicKey, convPrivateKey, convPublicKey)
                            saveUserData()
                            result.success("Contact $contactId added.")
                        } else {
                            result.error("ADD_CONTACT_ERROR", "Invalid contact ID or already exists.", null)
                        }
                    }
                    "sendMessage" -> {
                        val recipientId = call.argument<String>("recipientId")
                        val messageContent = call.argument<String>("messageContent")

                        if (recipientId == null || messageContent == null) {
                            result.error("SEND_ERROR", "Recipient ID or message content missing.", null)
                            return@setMethodCallHandler
                        }

                        val contactInfo = contacts[recipientId]
                        if (contactInfo == null) {
                            result.error("SEND_ERROR", "Contact not found. Add them first.", null)
                            return@setMethodCallHandler
                        }

                        try {
                            // 1. Generate AES key
                            val aesKeyBase64 = generate_aes_key_ffi()

                            // 2. Encrypt message with AES
                            val encryptedMessageJson = encrypt_message_with_aes_ffi(messageContent, aesKeyBase64)
                            val encryptedMessage = JSONObject(encryptedMessageJson)
                            val ivBase64 = encryptedMessage.getString("iv")
                            val ciphertextBase64 = encryptedMessage.getString("ciphertext")

                            // 3. Encrypt AES key with the recipient's public key (from contactInfo)
                            val encryptedAesKeyBase64 = encrypt_aes_key_with_rsa_ffi(aesKeyBase64, contactInfo.publicKey)

                            // 4. Construct message payload (simulated)
                            val messagePayload = JSONObject().apply {
                                put("senderId", currentUserId)
                                put("recipientId", recipientId)
                                put("encryptedAesKey", encryptedAesKeyBase64)
                                put("iv", ivBase64)
                                put("ciphertext", ciphertextBase64)
                                put("timestamp", System.currentTimeMillis())
                            }

                            // Simulate P2P send (write to recipient's inbox file)
                            val recipientInboxFile = getInboxFile(recipientId)
                            val messagesInInbox = if (recipientInboxFile.exists()) {
                                try {
                                    JSONObject(recipientInboxFile.readText()).optJSONArray("messages") ?: JSONArray()
                                } catch (e: Exception) {
                                    JSONArray() // Handle malformed JSON
                                }
                            } else {
                                JSONArray()
                            }
                            messagesInInbox.put(messagePayload)
                            JSONObject().apply { put("messages", messagesInInbox) }.write(recipientInboxFile)

                            result.success("Message sent (simulated P2P).")
                        } catch (e: Exception) {
                            result.error("ENCRYPTION_ERROR", "Failed to encrypt/send message: ${e.message}", e.toString())
                        }
                    }
                    else -> result.notImplemented()
                }
            }

            eventChannel = EventChannel(flutterEngine.dartExecutor.binaryMessenger, EVENT_CHANNEL_NAME)
            eventChannel.setStreamHandler(object : EventChannel.StreamHandler {
                override fun onListen(arguments: Any?, sink: EventChannel.EventSink) {
                    eventSink = sink
                    // Start a background task to check for incoming messages periodically
                    // In a real app, this would be a listener for actual P2P connections
                    Thread {
                        while (true) {
                            Thread.sleep(5000) // Check every 5 seconds
                            currentUserId?.let { userId ->
                                val inboxFile = getInboxFile(userId)
                                if (inboxFile.exists()) {
                                    try {
                                        val inboxContent = JSONObject(inboxFile.readText())
                                        val messagesArray = inboxContent.optJSONArray("messages") ?: JSONArray()
                                        if (messagesArray.length() > 0) {
                                            val newMessages = mutableListOf<JSONObject>()
                                            for (i in 0 until messagesArray.length()) {
                                                newMessages.add(messagesArray.getJSONObject(i))
                                            }
                                            // Clear inbox after reading
                                            JSONObject().apply { put("messages", JSONArray()) }.write(inboxFile)

                                            newMessages.forEach { rawMessage ->
                                                try {
                                                    val senderId = rawMessage.getString("senderId")
                                                    val encryptedAesKeyBase64 = rawMessage.getString("encryptedAesKey")
                                                    val ivBase64 = rawMessage.getString("iv")
                                                    val ciphertextBase64 = rawMessage.getString("ciphertext")

                                                    val contactInfo = contacts[senderId]
                                                    if (contactInfo == null) {
                                                        eventSink?.error("DECRYPT_ERROR", "No contact info for $senderId. Cannot decrypt.", null)
                                                        return@forEach
                                                    }

                                                    // Decrypt AES key with our conversation-specific private key
                                                    val decryptedAesKeyBase64 = decrypt_aes_key_with_rsa_ffi(encryptedAesKeyBase64, contactInfo.conversationPrivateKey)

                                                    // Decrypt message content with AES key
                                                    val decryptedMessage = decrypt_message_with_aes_ffi(ivBase64, ciphertextBase64, decryptedAesKeyBase64)

                                                    eventSink?.success("From $senderId: $decryptedMessage")
                                                } catch (e: Exception) {
                                                    eventSink?.error("DECRYPT_ERROR", "Failed to decrypt message: ${e.message}", rawMessage.toString())
                                                }
                                            }
                                        }
                                    } catch (e: Exception) {
                                        // Handle JSON parsing errors for inbox file
                                        eventSink?.error("INBOX_READ_ERROR", "Failed to read inbox: ${e.message}", null)
                                    }
                                }
                            }
                        }
                    }.start()
                }

                override fun onCancel(arguments: Any?) {
                    eventSink = null
                }
            })
        }
    }

    // Extension function to write JSONObject to file
    fun JSONObject.write(file: File) {
        file.writeText(this.toString())
    }
    ```

### Step 5: iOS Native Module (Swift)

For iOS, you'll integrate the Rust static library (`.a` files) into your Xcode project.

1.  **Place Rust Libraries:**
    After building the Rust library for iOS (see Step 2.4), you'll need to integrate the compiled `.a` files into your Xcode project. This typically involves:
    *   Opening `decentralized_messenger_app/ios/Runner.xcworkspace` in Xcode.
    *   Dragging the `.a` files into your Xcode project navigator.
    *   Ensuring they are linked in `Build Phases -> Link Binary With Libraries`.
    *   If you generate a C header from your Rust library (e.g., using `cbindgen`), you'll need to include it in your bridging header.

2.  **Modify `ios/Runner/AppDelegate.swift`:**
    Open `decentralized_messenger_app/ios/Runner/AppDelegate.swift` and modify it to set up platform channels and call into your Rust library.

    ```swift
    // decentralized_messenger_app/ios/Runner/AppDelegate.swift
    import UIKit
    import Flutter

    // Import your Rust FFI headers (if you have them, or use direct C function calls)
    // For example, if you generated a C header from your Rust library:
    // #import "decentralized_messenger_core.h" // You might need a bridging header for this

    @UIApplicationMain
    @objc class AppDelegate: FlutterAppDelegate {
      // Declare native functions from Rust (assuming C-compatible signatures)
      // You'll need to define these in a bridging header or directly in Swift if possible
      // Example:
      /*
      @_silgen_name("generate_rsa_key_pair_ffi")
      func generate_rsa_key_pair_ffi() -> UnsafeMutablePointer<CChar>

      @_silgen_name("encrypt_aes_key_with_rsa_ffi")
      func encrypt_aes_key_with_rsa_ffi(aesKeyBase64: UnsafePointer<CChar>, recipientPublicKeyPem: UnsafePointer<CChar>) -> UnsafeMutablePointer<CChar>

      // ... and so on for all Rust FFI functions
      */

      // --- Simulated User Data and P2P Storage (similar to Android) ---
      // You'd implement Swift equivalents for saving/loading user data and simulating inboxes
      // using UserDefaults or FileManager for local storage.
      // Example:
      private var currentUserId: String?
      private var myPublicKey: String?
      private var myPrivateKey: String?
      private var contacts: [String: [String: String]] = [:] // contactId -> {publicKey, conversationPrivateKey, conversationPublicKey}

      private func getUserDataPath() -> URL {
          return FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0].appendingPathComponent("user_data.json")
      }

      private func getInboxPath(userId: String) -> URL {
          return FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0].appendingPathComponent("inbox_\(userId).json")
      }

      private func saveUserData() {
          let userData: [String: Any?] = [
              "userId": currentUserId,
              "publicKey": myPublicKey,
              "privateKey": myPrivateKey,
              "contacts": contacts
          ]
          do {
              let data = try JSONSerialization.data(withJSONObject: userData, options: .prettyPrinted)
              try data.write(to: getUserDataPath())
          } catch {
              print("Failed to save user data: \(error)")
          }
      }

      private func loadUserData() {
          do {
              let data = try Data(contentsOf: getUserDataPath())
              if let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                  currentUserId = json["userId"] as? String
                  myPublicKey = json["publicKey"] as? String
                  myPrivateKey = json["privateKey"] as? String
                  contacts = json["contacts"] as? [String: [String: String]] ?? [:]
              }
          } catch {
              print("Failed to load user data: \(error)")
          }
      }
      // --- End Simulated User Data and P2P Storage ---


      override func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
      ) -> Bool {
        let controller : FlutterViewController = window?.rootViewController as! FlutterViewController
        let methodChannel = FlutterMethodChannel(name: "com.example.decentralized_messenger/p2p_methods",
                                                 binaryMessenger: controller.binaryMessenger)
        let eventChannel = FlutterEventChannel(name: "com.example.decentralized_messenger/p2p_events",
                                                binaryMessenger: controller.binaryMessenger)

        loadUserData() // Load user data on startup

        methodChannel.setMethodCallHandler { [weak self] (call: FlutterMethodCall, result: @escaping FlutterResult) in
          guard let self = self else { return }
          switch call.method {
          case "initUser":
            if self.currentUserId == nil {
                // Call Rust FFI: generate_rsa_key_pair_ffi()
                // Example (assuming FFI is set up):
                // let keyPairJsonPtr = generate_rsa_key_pair_ffi()
                // let keyPairJson = String(cString: keyPairJsonPtr)
                // free_cstring(keyPairJsonPtr) // Free memory if Rust allocated
                // let keyPair = try? JSONSerialization.jsonObject(with: keyPairJson.data(using: .utf8)!) as? [String: String]
                // self.myPublicKey = keyPair?["public_key_pem"]
                // self.myPrivateKey = keyPair?["private_key_pem"]
                self.currentUserId = UUID().uuidString.replacingOccurrences(of: "-", with: "").prefix(100).description // 100-char ID
                self.saveUserData()
            }
            result([
                "userId": self.currentUserId,
                "publicKey": self.myPublicKey ?? "ERROR"
            ])
          case "addContact":
            guard let args = call.arguments as? [String: Any],
                  let contactId = args["contactId"] as? String,
                  let contactPublicKey = args["contactPublicKey"] as? String else {
                result(FlutterError(code: "INVALID_ARGUMENTS", message: "Missing contactId or contactPublicKey", details: nil))
                return
            }

            if self.contacts[contactId] == nil {
                // Generate conversation-specific keys
                // let convKeyPairJsonPtr = generate_rsa_key_pair_ffi()
                // let convKeyPairJson = String(cString: convKeyPairJsonPtr)
                // free_cstring(convKeyPairJsonPtr)
                // let convKeyPair = try? JSONSerialization.jsonObject(with: convKeyPairJson.data(using: .utf8)!) as? [String: String]

                self.contacts[contactId] = [
                    "publicKey": contactPublicKey,
                    "conversationPrivateKey": "DUMMY_CONV_PRIVATE_KEY", // convKeyPair?["private_key_pem"]
                    "conversationPublicKey": "DUMMY_CONV_PUBLIC_KEY" // convKeyPair?["public_key_pem"]
                ]
                self.saveUserData()
                result("Contact \(contactId) added.")
            } else {
                result(FlutterError(code: "ADD_CONTACT_ERROR", message: "Contact already exists.", details: nil))
            }
          case "sendMessage":
            guard let args = call.arguments as? [String: Any],
                  let recipientId = args["recipientId"] as? String,
                  let messageContent = args["messageContent"] as? String else {
                result(FlutterError(code: "INVALID_ARGUMENTS", message: "Missing recipientId or messageContent", details: nil))
                return
            }

            guard let contactInfo = self.contacts[recipientId] else {
                result(FlutterError(code: "SEND_ERROR", message: "Contact not found. Add them first.", nil))
                return
            }

            do {
                // 1. Generate AES key (Rust FFI)
                // let aesKeyBase64Ptr = generate_aes_key_ffi()
                // let aesKeyBase64 = String(cString: aesKeyBase64Ptr)
                // free_cstring(aesKeyBase64Ptr)

                // 2. Encrypt message with AES (Rust FFI)
                // let encryptedMessageJsonPtr = encrypt_message_with_aes_ffi(messageContent.cString(using: .utf8)!, aesKeyBase64.cString(using: .utf8)!)
                // let encryptedMessageJson = String(cString: encryptedMessageJsonPtr)
                // free_cstring(encryptedMessageJsonPtr)
                // let encryptedMessage = try JSONSerialization.jsonObject(with: encryptedMessageJson.data(using: .utf8)!) as? [String: String]
                // let ivBase64 = encryptedMessage?["iv"] ?? ""
                // let ciphertextBase64 = encryptedMessage?["ciphertext"] ?? ""

                // 3. Encrypt AES key with recipient's public key (Rust FFI)
                // let encryptedAesKeyBase64Ptr = encrypt_aes_key_with_rsa_ffi(aesKeyBase64.cString(using: .utf8)!, contactInfo["publicKey"]!.cString(using: .utf8)!)
                // let encryptedAesKeyBase64 = String(cString: encryptedAesKeyBase64Ptr)
                // free_cstring(encryptedAesKeyBase64Ptr)

                // 4. Construct message payload (simulated)
                let messagePayload: [String: Any] = [
                    "senderId": self.currentUserId ?? "UNKNOWN",
                    "recipientId": recipientId,
                    "encryptedAesKey": "DUMMY_ENCRYPTED_AES_KEY", // encryptedAesKeyBase64
                    "iv": "DUMMY_IV", // ivBase64
                    "ciphertext": "DUMMY_CIPHERTEXT", // ciphertextBase64
                    "timestamp": Date().timeIntervalSince1970 * 1000
                ]

                // Simulate P2P send (write to recipient's inbox file)
                let inboxPath = self.getInboxPath(userId: recipientId)
                var messagesInInbox: [[String: Any]] = []
                if FileManager.default.fileExists(atPath: inboxPath.path) {
                    if let data = try? Data(contentsOf: inboxPath),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
                       let messages = json["messages"] as? [[String: Any]] {
                        messagesInInbox = messages
                    }
                }
                messagesInInbox.append(messagePayload)
                let inboxContent: [String: Any] = ["messages": messagesInInbox]
                let dataToWrite = try JSONSerialization.data(withJSONObject: inboxContent, options: .prettyPrinted)
                try dataToWrite.write(to: inboxPath)

                result("Message sent (iOS simulated P2P).")
            } catch {
                result(FlutterError(code: "ENCRYPTION_ERROR", message: "Failed to encrypt/send message: \(error.localizedDescription)", details: nil))
            }
          default:
            result(FlutterMethodNotImplemented)
          }
        }

        eventChannel.setStreamHandler(self) // Set AppDelegate as the stream handler

        GeneratedPluginRegistrant.register(with: self)
        return super.application(application, didFinishLaunchingWithOptions: launchOptions)
      }
    }

    extension AppDelegate: FlutterStreamHandler {
      func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -> FlutterError? {
        // Start a background task to check for incoming messages (simulated)
        // In a real app, this would be a listener for actual P2P connections
        DispatchQueue.global(qos: .background).async { [weak self] in
            guard let self = self else { return }
            while true {
                Thread.sleep(forTimeInterval: 5.0) // Check every 5 seconds
                guard let userId = self.currentUserId else { continue }
                let inboxPath = self.getInboxPath(userId: userId)

                if FileManager.default.fileExists(atPath: inboxPath.path) {
                    do {
                        let data = try Data(contentsOf: inboxPath)
                        if let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
                           var messagesArray = json["messages"] as? [[String: Any]] {

                            if messagesArray.isEmpty { continue }

                            // Clear inbox after reading
                            let emptyInbox: [String: Any] = ["messages": []]
                            let emptyData = try JSONSerialization.data(withJSONObject: emptyInbox, options: .prettyPrinted)
                            try emptyData.write(to: inboxPath)

                            for rawMessage in messagesArray {
                                do {
                                    guard let senderId = rawMessage["senderId"] as? String,
                                          let encryptedAesKeyBase64 = rawMessage["encryptedAesKey"] as? String,
                                          let ivBase64 = rawMessage["iv"] as? String,
                                          let ciphertextBase64 = rawMessage["ciphertext"] as? String else {
                                        events(FlutterError(code: "DECRYPT_ERROR", message: "Malformed message received.", details: rawMessage))
                                        continue
                                    }

                                    guard let contactInfo = self.contacts[senderId] else {
                                        events(FlutterError(code: "DECRYPT_ERROR", message: "No contact info for \(senderId). Cannot decrypt.", details: nil))
                                        continue
                                    }

                                    // Decrypt AES key with our conversation-specific private key (Rust FFI)
                                    // let decryptedAesKeyBase64Ptr = decrypt_aes_key_with_rsa_ffi(encryptedAesKeyBase64.cString(using: .utf8)!, contactInfo["conversationPrivateKey"]!.cString(using: .utf8)!)
                                    // let decryptedAesKeyBase64 = String(cString: decryptedAesKeyBase64Ptr)
                                    // free_cstring(decryptedAesKeyBase64Ptr)

                                    // Decrypt message content with AES key (Rust FFI)
                                    // let decryptedMessagePtr = decrypt_message_with_aes_ffi(ivBase64.cString(using: .utf8)!, ciphertextBase64.cString(using: .utf8)!, decryptedAesKeyBase64.cString(using: .utf8)!)
                                    // let decryptedMessage = String(cString: decryptedMessagePtr)
                                    // free_cstring(decryptedMessagePtr)

                                    events("From \(senderId): DUMMY_DECRYPTED_MESSAGE") // decryptedMessage
                                } catch {
                                    events(FlutterError(code: "DECRYPT_ERROR", message: "Failed to decrypt message: \(error.localizedDescription)", details: rawMessage))
                                }
                            }
                        }
                    } catch {
                        events(FlutterError(code: "INBOX_READ_ERROR", message: "Failed to read inbox: \(error.localizedDescription)", details: nil))
                    }
                }
            }
        }
        return nil
      }

      func onCancel(withArguments arguments: Any?) -> FlutterError? {
        // Clean up background tasks (e.g., stop the Dispatch queue)
        return nil
      }
    }
    ```

### Step 6: Desktop (Windows, macOS, Linux) Integration

For desktop applications, Flutter's `dart:ffi` allows direct calls to native libraries (like your Rust `.dll`, `.dylib`, or `.so` files) without needing platform channels. This simplifies the integration significantly.

1.  **Place Rust Libraries:**
    You would place the compiled Rust libraries (`.dll` for Windows, `.dylib` for macOS, `.so` for Linux) in a location where your Flutter desktop executable can find them. Often, this is alongside the executable itself in the build output directory.

    *   **Windows:** `decentralized_messenger_app/build/windows/runner/Release/decentralized_messenger_core.dll`
    *   **macOS:** `decentralized_messenger_app/build/macos/Build/Products/Release/libdecentralized_messenger_core.dylib` (or within the app bundle's `Contents/Frameworks` or `Contents/Libraries`)
    *   **Linux:** `decentralized_messenger_app/build/linux/x64/release/bundle/libdecentralized_messenger_core.so`

2.  **Using FFI in your Flutter Desktop App:**
    In your `lib/main.dart` (or a separate service layer), you would directly call the `RustCore` methods from `lib/ffi_bridge.dart` instead of using `platformMethodChannel`. You'll need to add conditional logic to use FFI only when running on desktop platforms.

    ```dart
    // Example usage in lib/main.dart for desktop builds
    // (You'd need conditional imports or separate files for mobile vs desktop)

    // import 'package:decentralized_messenger_app/ffi_bridge.dart'; // For desktop

    // In _MessengerScreenState
    // You would modify _initMessenger and _sendMessage to use RustCore for desktop
    // and platform channels for mobile.

    // Example of how you might structure it:
    /*
    Future<void> _initMessenger() async {
      if (Platform.isAndroid || Platform.isIOS) {
        // Use platform channels
        try {
          final String result = await platformMethodChannel.invokeMethod('initUser');
          final Map<String, dynamic> userData = jsonDecode(result);
          setState(() {
            _myPublicKey = userData['publicKey'] ?? 'Error getting public key';
            _statusMessage = 'Initialized with ID: ${userData['userId']}';
          });
        } on PlatformException catch (e) {
          setState(() {
            _statusMessage = "Failed to initialize: '${e.message}'.";
          });
        }
      } else if (Platform.isWindows || Platform.isMacOS || Platform.isLinux) {
        // Use FFI directly
        try {
          final keyPair = RustCore.generateRsaKeyPair();
          setState(() {
            _myPublicKey = keyPair['public_key_pem'] ?? 'Error getting public key';
            _statusMessage = 'Initialized with desktop FFI.';
          });
          // You'd also need to manage user ID and private key storage locally (e.g., using path_provider)
        } catch (e) {
          setState(() {
            _statusMessage = "Failed to initialize desktop: '$e'.";
          });
        }
      }
    }

    Future<void> _sendMessage() async {
      // ... (recipientId, messageContent checks)

      if (Platform.isAndroid || Platform.isIOS) {
        // Use platform channels
        try {
          final String result = await platformMethodChannel.invokeMethod('sendMessage', {
            'recipientId': recipientId,
            'messageContent': messageContent,
          });
          setState(() {
            _statusMessage = result;
            _messages.add('Sent to $recipientId: $messageContent');
            _messageController.clear();
          });
        } on PlatformException catch (e) {
          setState(() {
            _statusMessage = "Failed to send message: '${e.message}'.";
          });
        }
      } else if (Platform.isWindows || Platform.isMacOS || Platform.isLinux) {
        // Use FFI directly
        try {
          final aesKeyBase64 = RustCore.generateAesKey();
          final encryptedMessage = RustCore.encryptMessageWithAes(messageContent, aesKeyBase64);
          final ivBase64 = encryptedMessage['iv']!;
          final ciphertextBase64 = encryptedMessage['ciphertext']!;

          // Simulate P2P send (e.g., write to a local file for the recipient's inbox)
          // This part would still need a desktop-specific P2P simulation or actual P2P implementation
          // For now, just demonstrate crypto:
          setState(() {
            _statusMessage = 'Message encrypted via Rust FFI.';
            _messages.add('Sent (FFI): $messageContent');
            _messageController.clear();
          });
        } catch (e) {
          setState(() {
            _statusMessage = "Failed to send desktop message: '$e'.";
          });
        }
      }
    }
    */
    ```

### Step 7: Building and Deploying the Flutter App

Navigate to the root of your Flutter project (`decentralized_messenger_app`).

*   **Android (using Android Studio):**
    1.  Open the `decentralized_messenger_app` project in Android Studio.
    2.  Android Studio will automatically detect the Android module.
    3.  Ensure your Rust `.so` files are correctly placed in `android/app/src/main/jniLibs/`.
    4.  **Run on Device/Emulator:** Select a device or emulator from the toolbar and click the "Run" (green play) button. Android Studio will build and deploy the app.
    5.  **Build APK/App Bundle:** `Build -> Build Bundle(s) / APK(s) -> Build APK(s)` or `Build Bundle(s)`. For release, use `Generate Signed Bundle / APK`.

*   **iOS (using Xcode):**
    1.  Open the `decentralized_messenger_app/ios/Runner.xcworkspace` file in Xcode.
    2.  Configure your Xcode project to link against the Rust static libraries (`.a` files) and set up any necessary bridging headers.
    3.  **Run on Device/Simulator:** Select a target device or simulator from the scheme dropdown and click the "Run" button. Xcode will build and deploy.
    4.  **Archive for App Store:** `Product -> Archive`. This will create an archive that you can then distribute via App Store Connect.

*   **Windows Desktop:**
    1.  Enable Windows desktop support for Flutter: `flutter config --enable-windows-desktop`
    2.  **Build:** `flutter build windows`
    3.  **Deployment:** The executable and necessary DLLs (including your Rust `decentralized_messenger_core.dll`) will be in `build/windows/runner/Release`. You can then package these files (e.g., into an installer).

*   **macOS Desktop:**
    1.  Enable macOS desktop support for Flutter: `flutter config --enable-macos-desktop`
    2.  **Build:** `flutter build macos`
    3.  **Deployment:** The app bundle will be in `build/macos/Build/Products/Release/decentralized_messenger_app.app`. You can distribute this directly or package it into a `.dmg`. Ensure your Rust `libdecentralized_messenger_core.dylib` is correctly bundled within the app.

*   **Linux Desktop:**
    1.  Enable Linux desktop support for Flutter: `flutter config --enable-linux-desktop`
    2.  **Build:** `flutter build linux`
    3.  **Deployment:** The executable and necessary `.so` files (including your Rust `libdecentralized_messenger_core.so`) will be in `build/linux/x64/release/bundle`. You can then package these (e.g., into a `.deb` or `.rpm` package).

## Further Development Considerations

*   **Real P2P Implementation:** The most significant challenge is replacing the simulated P2P communication with actual native implementations for Bluetooth, Wi-Fi Direct, UWB, and NFC. This will involve extensive platform-specific coding and handling of permissions, background processes, and device discovery.
*   **Location-Based Blocking:** Integrate with actual location services (GPS) and potentially a "what-three-words" API. The logic for blocking by location would reside in the native P2P layer or be managed by the Flutter app based on location data.
*   **User Data Persistence:** Implement robust local storage for user IDs, keys, and contact information.
*   **Error Handling and UI Feedback:** Enhance the Flutter UI with more comprehensive error handling and user feedback.
*   **Background Operation:** For a messaging app, handling message reception when the app is in the background or closed is crucial and requires platform-specific background services.
*   **Battery Life:** Optimize the P2P communication to minimize battery drain.
*   **Network Topology & Routing:** For a truly decentralized mesh network, you'll need to design and implement sophisticated routing algorithms for messages to hop through intermediate devices.
*   **Security:** Beyond cryptography, ensure the P2P communication itself is secure against various attacks.
*   **Initial Device Discovery:** How do devices initially find each other without a central server? This is a complex problem that might require a hybrid approach (e.g., temporary internet-based rendezvous).
