# Decentralized Messenger Project

This repository contains the foundational code for a decentralized messaging application, designed to enable direct device-to-device communication without relying on central servers. The project is structured into a Python-based backend/CLI, a Rust core library for cryptographic operations, and a Flutter-based cross-platform user interface.

**Important Disclaimer:**
Implementing real, cross-platform peer-to-peer communication over low-level technologies like Bluetooth, Wi-Fi Direct, NFC, and UWB is **extremely complex** and requires deep knowledge of each operating system's native APIs. This project provides a conceptual framework and foundational code, but the full implementation of the native P2P communication layer will be a significant undertaking. For demonstration purposes, the Python backend and Android native module include *simulated* P2P layers using local file storage.

## Architecture Overview

The application is structured into three main layers:

1.  **Python Backend/CLI:**
    *   **Purpose:** Provides the core messaging logic, user management, and a command-line interface for interaction. It handles the orchestration of cryptographic operations and simulated P2P communication.
    *   **Technology:** Python.
    *   **Components:**
        *   `main.py`: The main entry point for the command-line interface, orchestrating user interactions, message sending, and receiving.
        *   `user_manager.py`: Manages user identities, generates and stores RSA key pairs, and handles contact information (including conversation-specific keys).
        *   `crypto_utils.py`: Encapsulates cryptographic functions for RSA key generation, encryption/decryption of AES keys with RSA, and AES encryption/decryption of messages.
        *   `message_protocol.py`: Defines the structure and serialization/deserialization of messages exchanged between users.
        *   `p2p_sim.py`: Simulates peer-to-peer communication by writing and reading messages from local "inbox" files for different users.
        *   `location_manager.py`: A placeholder for future integration with location services, intended for location-based blocking features.

2.  **Core Logic (Rust Library):**
    *   **Purpose:** Handles all critical, platform-independent cryptographic operations. This library is designed to be compiled into native libraries for various target platforms, offering performance and memory safety.
    *   **Technology:** Rust.
    *   **Output:** Native static/dynamic libraries (`.a`, `.so`, `.dylib`, `.dll`) for each target OS.

3.  **User Interface (Flutter):**
    *   **Purpose:** Provides the cross-platform graphical user interface for the application. It communicates with the native P2P communication modules (or directly with the Rust core on desktop) and the Python backend (conceptually, via a local API or similar for a full integration).
    *   **Technology:** Flutter (Dart). This allows a single UI codebase to run on iOS, Android, Windows, macOS, and Linux.

## Project Structure

```
decentralized_messenger/
├── crypto_utils.py             # Python: Cryptographic utilities
├── location_manager.py         # Python: Placeholder for location management
├── main.py                     # Python: CLI application entry point
├── message_protocol.py         # Python: Defines message structure
├── p2p_sim.py                  # Python: Simulated P2P communication (file-based inboxes)
├── user_manager.py             # Python: Manages user identities and contacts
├── .git/                       # Git repository data
├── data/
│   ├── inboxes/                # Simulated message inboxes for P2P_sim.py
│   └── users/                  # Stores user key pairs and contact data for user_manager.py
├── decentralized_messenger_app/ # Flutter application and Rust core
│   ├── pubspec.yaml
│   ├── README.md               # Original README for the Flutter app
│   ├── android/                # Android project (generated by Flutter)
│   │   └── app/
│   │       └── src/
│   │           └── main/
│   │               └── kotlin/
│   │                   └── com/
│   ├── decentralized_messenger_core/  # Rust core library
│   │   ├── Cargo.toml
│   │   └── src/
│   │       └── lib.rs
│   └── lib/                    # Flutter Dart code
│       ├── ffi_bridge.dart     # Dart FFI bindings for desktop
│       └── main.dart
└── venv/                       # Python virtual environment
```

## Setup and Building Instructions

### 1. Python Backend Setup

The Python backend provides the core logic and a CLI for testing.

1.  **Create and Activate Virtual Environment:**
    ```bash
    python3 -m venv venv
    source venv/bin/activate
    ```

2.  **Install Dependencies:**
    ```bash
    pip install cryptography
    ```

3.  **Run the CLI Application:**
    ```bash
    python main.py
    ```
    This will launch the interactive CLI where you can create users, add contacts, and send/receive simulated messages. User data and simulated inboxes will be stored in the `data/` directory.

### 2. Rust Core Library Setup

The Rust core library handles cryptographic operations for the Flutter application.

1.  **Navigate to the Rust project directory:**
    ```bash
    cd decentralized_messenger_app/decentralized_messenger_core
    ```

2.  **Ensure `Cargo.toml` and `src/lib.rs` are present:**
    These files define the Rust project and its cryptographic functions. Refer to `decentralized_messenger_app/README.md` for their content.

3.  **Build the Rust Library:**
    You need to have the Rust toolchain installed. Follow the instructions at [https://rustup.rs/](https://rustup.rs/).
    *   **Add Target Platforms:**
        ```bash
        rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android # Android
        rustup target add aarch64-apple-ios armv7-apple-ios x86_64-apple-ios aarch64-apple-ios-sim # iOS
        rustup target add x86_64-pc-windows-msvc # Windows
        rustup target add x86_64-unknown-linux-gnu # Linux
        rustup target add x86_64-apple-darwin # macOS
        ```
    *   **Build Commands (example for Android):**
        ```bash
        # Install cargo-ndk if you haven't already
        cargo install cargo-ndk
        # Build for common Android architectures
        cargo ndk build --target aarch64-linux-android --release
        # ... (repeat for other targets as needed, see decentralized_messenger_app/README.md)
        ```
    Compiled libraries (`.so`, `.a`, `.dll`, `.dylib`) will be found in `target/<platform_target>/release/`.

### 3. Flutter Application Setup

The Flutter application provides the cross-platform UI.

1.  **Create the Flutter Project (if not already created):**
    If you don't have Flutter installed, follow the official Flutter installation guide: [https://flutter.dev/docs/get-started/install](https://flutter.dev/docs/get-started/install)
    ```bash
    flutter create decentralized_messenger_app
    cd decentralized_messenger_app
    ```
    (Note: This project assumes `decentralized_messenger_app` already exists within the main `decentralized_messenger` directory.)

2.  **Configure `pubspec.yaml`:**
    Ensure `decentralized_messenger_app/pubspec.yaml` includes the necessary dependencies (`ffi`, `path_provider`, etc.). Refer to `decentralized_messenger_app/README.md` for the exact content.

3.  **Place Rust Libraries for Flutter:**
    Copy the compiled Rust `.so` files (for Android) into `decentralized_messenger_app/android/app/src/main/jniLibs/` (create subdirectories like `aarch64-v8a` as needed). For iOS, Windows, macOS, and Linux, follow the specific instructions in `decentralized_messenger_app/README.md` regarding library placement and Xcode/build configurations.

4.  **Configure Android Native Module (`MainActivity.kt`):**
    The `decentralized_messenger_app/android/app/src/main/kotlin/.../MainActivity.kt` file contains the Android-specific logic for interacting with the Rust library and simulating P2P communication.

5.  **Configure iOS Native Module (`AppDelegate.swift`):**
    The `decentralized_messenger_app/ios/Runner/AppDelegate.swift` file contains the iOS-specific logic.

6.  **Desktop (Windows, macOS, Linux) Integration:**
    The `decentralized_messenger_app/lib/ffi_bridge.dart` file demonstrates how Flutter's `dart:ffi` can directly interact with the Rust libraries on desktop platforms.

7.  **Building and Deploying the Flutter App:**
    Navigate to the `decentralized_messenger_app` directory and use standard Flutter commands:
    ```bash
    flutter run # To run on a connected device/emulator
    flutter build <platform> # e.g., flutter build apk, flutter build ios, flutter build windows
    ```
    Refer to `decentralized_messenger_app/README.md` for detailed build and deployment instructions for each platform.

## Further Development Considerations

*   **Real P2P Implementation:** The most significant challenge is replacing the simulated P2P communication (in both Python and Flutter native modules) with actual native implementations for Bluetooth, Wi-Fi Direct, UWB, and NFC. This will involve extensive platform-specific coding and handling of permissions, background processes, and device discovery.
*   **Integration of Python Backend with Flutter:** Currently, the Python backend and Flutter app operate somewhat independently (with the Python `p2p_sim.py` and Flutter native modules both simulating P2P). For a fully integrated application, you would need to establish communication between the Flutter UI and the Python backend (e.g., via a local REST API, gRPC, or a more direct inter-process communication mechanism).
*   **Location-Based Blocking:** Integrate with actual location services (GPS) and potentially a "what-three-words" API. The logic for blocking by location would reside in the native P2P layer or be managed by the Flutter app based on location data.
*   **User Data Persistence:** Implement robust local storage for user IDs, keys, and contact information across all components.
*   **Error Handling and UI Feedback:** Enhance the Flutter UI with more comprehensive error handling and user feedback.
*   **Background Operation:** For a messaging app, handling message reception when the app is in the background or closed is crucial and requires platform-specific background services.
*   **Battery Life:** Optimize the P2P communication to minimize battery drain.
*   **Network Topology & Routing:** For a truly decentralized mesh network, you'll need to design and implement sophisticated routing algorithms for messages to hop through intermediate devices.
*   **Security:** Beyond cryptography, ensure the P2P communication itself is secure against various attacks.
*   **Initial Device Discovery:** How do devices initially find each other without a central server? This is a complex problem that might require a hybrid approach (e.g., temporary internet-based rendezvous).
